#include <iostream>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <utility>

using namespace std;

struct Cell {
    bool visited = false;
    bool topWall = true;
    bool rightWall = true;
    bool bottomWall = true;
    bool leftWall = true;
};

using Maze = vector<vector<Cell>>;

void initializeMaze(Maze& maze, int width, int height) {
    maze.resize(height, vector<Cell>(width));
}

bool isValid(int x, int y, int width, int height) {
    return x >= 0 && y >= 0 && x < width && y < height;
}

vector<pair<int, int>> getUnvisitedNeighbors(const Maze& maze, int x, int y) {
    vector<pair<int, int>> neighbors;
    const vector<pair<int, int>> directions{{0, -1}, {1, 0}, {0, 1}, {-1, 0}}; // N, E, S, W
for (const auto& direction : directions) {
    int dx = direction.first;
    int dy = direction.second;
    int nx = x + dx;
    int ny = y + dy;
    if (isValid(nx, ny, maze[0].size(), maze.size()) && !maze[ny][nx].visited) {
        neighbors.emplace_back(nx, ny);
    }
}
return neighbors;
}

void generateMaze(Maze& maze) {
    srand(time(nullptr));
    vector<pair<int, int>> frontier;
    int startX = 0; // Start from the top-left corner
    int startY = 0;
    maze[startY][startX].visited = true;
    frontier.push_back({startX, startY});

    while (!frontier.empty()) {
        int randIndex = rand() % frontier.size();
        auto pair = frontier[randIndex];
		int x = pair.first;
		int y = pair.second;
        frontier.erase(frontier.begin() + randIndex);

        auto neighbors = getUnvisitedNeighbors(maze, x, y);
        if (!neighbors.empty()) {
            auto neighbor = neighbors[rand() % neighbors.size()];
			int nx = neighbor.first;
			int ny = neighbor.second;


            if (nx > x) maze[y][x].rightWall = maze[ny][nx].leftWall = false;
            else if (nx < x) maze[y][x].leftWall = maze[ny][nx].rightWall = false;
            else if (ny > y) maze[y][x].bottomWall = maze[ny][nx].topWall = false;
            else if (ny < y) maze[y][x].topWall = maze[ny][nx].bottomWall = false;

            maze[ny][nx].visited = true;
            frontier.push_back({nx, ny});
            frontier.insert(frontier.end(), neighbors.begin(), neighbors.end());
        }
    }
}

void printMaze(const Maze& maze) {
    for (int y = 0; y < maze.size(); y++) {
        // Top row of cells
        for (int x = 0; x < maze[0].size(); x++) {
            cout << (maze[y][x].topWall ? "+---" : "+   ");
        }
        cout << "+" << endl; // Rightmost boundary

        // Cell rows
        for (int x = 0; x < maze[0].size(); x++) {
            cout << (maze[y][x].leftWall ? "|   " : "    ");
        }
        cout << "|" << endl; // Rightmost boundary
    }

    // Bottom row of the maze
    for (int x = 0; x < maze[0].size(); x++) {
        cout << "+---";
    }
    cout << "+" << endl;
}

int main() {
    int width, height;
    cout << "Enter the width and height of the maze: ";
    cin >> width >> height;

    Maze maze;
    initializeMaze(maze, width, height);
    generateMaze(maze);
    printMaze(maze);

    return 0;
}
