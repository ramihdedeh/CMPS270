#include <SFML/Graphics.hpp>
#include <iostream>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <utility>

using namespace std;

struct Cell {
    bool visited = false;
    bool topWall = true;
    bool rightWall = true;
    bool bottomWall = true;
    bool leftWall = true;
};

using Maze = vector<vector<Cell>>;


void initializeMaze(Maze& maze, int width, int height) {
    maze.resize(height, vector<Cell>(width));
}

bool isValid(int x, int y, int width, int height) {
    return x >= 0 && y >= 0 && x < width && y < height;
}

vector<pair<int, int>> getUnvisitedNeighbors(const Maze& maze, int x, int y) {
    vector<pair<int, int>> neighbors;
    const vector<pair<int, int>> directions{{0, -1}, {1, 0}, {0, 1}, {-1, 0}}; // N, E, S, W
for (const auto& direction : directions) {
    int dx = direction.first;
    int dy = direction.second;
    int nx = x + dx;
    int ny = y + dy;
    if (isValid(nx, ny, maze[0].size(), maze.size()) && !maze[ny][nx].visited) {
        neighbors.emplace_back(nx, ny);
    }
}
return neighbors;
}

void generateMaze(Maze& maze) {
    srand(time(nullptr));
    vector<pair<int, int>> frontier;
    int startX = 0; // Start from the top-left corner
    int startY = 0;
    maze[startY][startX].visited = true;
    frontier.push_back({startX, startY});

    while (!frontier.empty()) {
        int randIndex = rand() % frontier.size();
        auto pair = frontier[randIndex];
		int x = pair.first;
		int y = pair.second;
        frontier.erase(frontier.begin() + randIndex);

        auto neighbors = getUnvisitedNeighbors(maze, x, y);
        if (!neighbors.empty()) {
            auto neighbor = neighbors[rand() % neighbors.size()];
			int nx = neighbor.first;
			int ny = neighbor.second;


            if (nx > x) maze[y][x].rightWall = maze[ny][nx].leftWall = false;
            else if (nx < x) maze[y][x].leftWall = maze[ny][nx].rightWall = false;
            else if (ny > y) maze[y][x].bottomWall = maze[ny][nx].topWall = false;
            else if (ny < y) maze[y][x].topWall = maze[ny][nx].bottomWall = false;

            maze[ny][nx].visited = true;
            frontier.push_back({nx, ny});
            frontier.insert(frontier.end(), neighbors.begin(), neighbors.end());
        }
    }
}

void printMaze(const Maze& maze) {
    for (int y = 0; y < maze.size(); y++) {
        // Top row of cells
        for (int x = 0; x < maze[0].size(); x++) {
            cout << (maze[y][x].topWall ? "+---" : "+   ");
        }
        cout << "+" << endl; // Rightmost boundary

        // Cell rows
        for (int x = 0; x < maze[0].size(); x++) {
            cout << (maze[y][x].leftWall ? "|   " : "    ");
        }
        cout << "|" << endl; // Rightmost boundary
    }

    // Bottom row of the maze
    for (int x = 0; x < maze[0].size(); x++) {
        cout << "+---";
    }
    cout << "+" << endl;
}

void drawMaze(const Maze& maze, sf::RenderWindow& window) {
    int cellSize = 30; // Size of each cell square, adjust as necessary
    sf::RectangleShape wall(sf::Vector2f(cellSize, cellSize));

    window.clear(sf::Color::White);
    for (int y = 0; y < maze.size(); y++) {
        for (int x = 0; x < maze[0].size(); x++) {
            int posX = x * cellSize;
            int posY = y * cellSize;

            // Draw cell walls based on the Cell properties
            if (maze[y][x].topWall) {
                sf::RectangleShape topWall(sf::Vector2f(cellSize, 2));
                topWall.setPosition(posX, posY);
                topWall.setFillColor(sf::Color::Black);
                window.draw(topWall);
            }
            if (maze[y][x].rightWall) {
                sf::RectangleShape rightWall(sf::Vector2f(2, cellSize));
                rightWall.setPosition(posX + cellSize, posY);
                rightWall.setFillColor(sf::Color::Black);
                window.draw(rightWall);
            }
            if (maze[y][x].bottomWall) {
                sf::RectangleShape bottomWall(sf::Vector2f(cellSize, 2));
                bottomWall.setPosition(posX, posY + cellSize);
                bottomWall.setFillColor(sf::Color::Black);
                window.draw(bottomWall);
            }
            if (maze[y][x].leftWall) {
                sf::RectangleShape leftWall(sf::Vector2f(2, cellSize));
                leftWall.setPosition(posX, posY);
                leftWall.setFillColor(sf::Color::Black);
                window.draw(leftWall);
            }
        }
    }
    window.display();
}

int main() {
    int width, height;
    cout << "Enter the width and height of the maze: ";
    cin >> width >> height;

    Maze maze;
    initializeMaze(maze, width, height);
    generateMaze(maze);

    sf::RenderWindow window(sf::VideoMode(width * 30, height * 30), "Maze Generator");

    while (window.isOpen()) {
        sf::Event event;
        while (window.pollEvent(event)) {
            if (event.type == sf::Event::Closed)
                window.close();
        }
        drawMaze(maze, window);
    }

    return 0;
}
